<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2ufkpfb9daxnik</title>
  <link rel="stylesheet" href="stylesheet.css">
</head>
<body class="theme-tsuki">
  <!-- èƒŒæ™¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
  <canvas id="background-canvas"></canvas>
  
  <div class="layout">
    <nav class="sidebar">
      <a class="home-link" href="index.html">home</a>
      <button class="theme-toggle" onclick="toggleTheme()">ğŸŒ™/â˜€ï¸</button>
      <div class="toc">
        <!-- ãã‚Œãã‚Œã®ãƒšãƒ¼ã‚¸ã¸ã®ãƒªãƒ³ã‚¯ -->
         <ul>
            <li><a href="pages/madelayout/">ã“ã‚Œã¾ã§ã«ä½œã£ãŸé…åˆ—</a></li>
            <li><a href="pages/javascriptVSjava/">JavaScriptã¨Javaã®é•ã„</a></li>
            <li><a href="template/">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ</a></li>
            <li><a href="pages/about/">ç§ã«ã¤ã„ã¦</a></li>
            <li><a href="pages/breakingthemaze/">è¿·è·¯ããšã—</a></li>
            <li><a href="pages/hsrtemporarydictionaryje/">å´©å£Šï¼šã‚¹ã‚¿ãƒ¼ãƒ¬ã‚¤ãƒ«ç°¡æ˜“å’Œè‹±è¾æ›¸</a></li>
            <li><a href="pages/input/">æ–‡å­—å…¥åŠ›ã«ã¤ã„ã¦</a></li>
            <li><a href="pages/portfolio/">2ufkpfb9daxnikã¯ã€ç§ã®githubã‚¢ã‚«ã‚¦ãƒ³ãƒˆåã§ã™ã€‚</a></li>
            <li><a href="pages/sample/">ã‚µãƒ³ãƒ—ãƒ«</a></li>
         </ul>
      </div>
    </nav>
    <main class="container">
      <div class="home-top">
        <a href="index.html">home</a>
        <button class="theme-toggle mobile-only" onclick="toggleTheme()">ğŸŒ™/â˜€ï¸</button>
      </div>
        <p>æ–°JISé…åˆ—ã‚„æœˆé…åˆ—ã®ç´¹ä»‹ã§æœ‰åãª<a href="https://jisx6004.client.jp/index.html">jisx6004.client.jp</a>ã®ãƒ‡ã‚¶ã‚¤ãƒ³ãŒå¥½ããªã®ã§ãƒ‘ã‚¯ã‚Šã¾ã—ãŸã€‚</p>
      <div class="home-bottom"><a href="index.html">home</a></div>
    </main>

    <main class="container">
        <p><a href="https://github.com/2ufkpfb9daxnik/portfolio">GitHub Repository</a></p>
    </main>

    <main class="container">
        <p>ä½œæˆæ—¥æ™‚ã¯ç‰¹ã«æ˜”ã®ã‚„ã¤ã¯çµæ§‹å£Šã‚Œã¦ã„ã¦ã€æœ¬å½“ã®ã¨ã“ã‚ãŒæ°—ã«ãªã‚‹æ–¹ã¯commit logã‚’ç¢ºèªã—ã¦ä¸‹ã•ã„ã€‚</p>
    </main>

    <main class="container">
        <p><a href="https://yyf999999999.github.io/typingprot/pages/difficultySelecter">ã‚²ãƒ¼ãƒ 1</a></p>
        <p><a href="https://yuga-school.github.io/puzzlegame/Roguelikepuzzle.html">ã‚²ãƒ¼ãƒ 2</a></p>
    </main>
    
    <!-- ã‚¹ãƒãƒ›ç”¨ã®è¨˜äº‹ãƒªãƒ³ã‚¯è¡¨ç¤º -->
    <div class="mobile-links-container">
      <h2>è¨˜äº‹ä¸€è¦§</h2>
      <ul class="mobile-links">
        <li><a href="pages/madelayout/">ã“ã‚Œã¾ã§ã«ä½œã£ãŸé…åˆ—</a></li>
        <li><a href="pages/javascriptVSjava/">JavaScriptã¨Javaã®é•ã„</a></li>
        <li><a href="template/">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ</a></li>
        <li><a href="pages/about/">ç§ã«ã¤ã„ã¦</a></li>
        <li><a href="pages/pyrrhula/">é·½</a></li>
        <li><a href="pages/breakingthemaze/">è¿·è·¯ããšã—</a></li>
        <li><a href="pages/hsrtemporarydictionaryje/">å´©å£Šï¼šã‚¹ã‚¿ãƒ¼ãƒ¬ã‚¤ãƒ«ç°¡æ˜“å’Œè‹±è¾æ›¸</a></li>
        <li><a href="pages/input/">æ–‡å­—å…¥åŠ›ã«ã¤ã„ã¦</a></li>
        <li><a href="pages/portfolio/">2ufkpfb9daxnikã¯ã€ç§ã®githubã‚¢ã‚«ã‚¦ãƒ³ãƒˆåã§ã™ã€‚</a></li>
        <li><a href="pages/sample/">ã‚µãƒ³ãƒ—ãƒ«</a></li>
      </ul>
    </div>
  </div>

  <script>
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹
    class AnimationManager {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.currentAnimation = null;
        this.time = 0;
        this.switchInterval = 500 + Math.random() * 500; // 0.5-1ç§’
        this.lastSwitchTime = 0;
        
        this.animations = [
          'particles',
          'ripples',
          'geometry',
          'constellation',
          'flowField',
          'spirals'
        ];
        
        this.resize();
        this.initAnimation();
        this.animate();
        
        window.addEventListener('resize', () => this.resize());
      }
      
      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        if (this.currentAnimation) {
          this.initAnimation();
        }
      }
      
      initAnimation() {
        const animationType = this.animations[Math.floor(Math.random() * this.animations.length)];
        
        switch (animationType) {
          case 'particles':
            this.initParticles();
            break;
          case 'ripples':
            this.initRipples();
            break;
          case 'geometry':
            this.initGeometry();
            break;
          case 'constellation':
            this.initConstellation();
            break;
          case 'flowField':
            this.initFlowField();
            break;
          case 'spirals':
            this.initSpirals();
            break;
        }
        
        this.currentAnimation = animationType;
        this.switchInterval = 500 + Math.random() * 500;
        this.lastSwitchTime = this.time;
      }
      
      // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
      initParticles() {
        this.particles = [];
        const count = 40;
        for (let i = 0; i < count; i++) {
          this.particles.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            size: Math.random() * 8 + 4,
            alpha: Math.random() * 0.5 + 0.2
          });
        }
      }
      
      // æ³¢ç´‹åŠ¹æœ
      initRipples() {
        this.ripples = [];
        this.rippleSpawnTimer = 0;
      }
      
      // å¹¾ä½•å­¦æ¨¡æ§˜
      initGeometry() {
        this.geometryTime = 0;
        this.shapes = [];
        for (let i = 0; i < 12; i++) {
          this.shapes.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.08,
            size: Math.random() * 100 + 60
          });
        }
      }
      
      // æ˜Ÿåº§é¢¨
      initConstellation() {
        this.stars = [];
        const count = 25;
        for (let i = 0; i < count; i++) {
          this.stars.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            vx: (Math.random() - 0.5) * 1.5,
            vy: (Math.random() - 0.5) * 1.5,
            size: Math.random() * 6 + 3,
            brightness: Math.random(),
            twinkle: Math.random() * 0.05 + 0.02
          });
        }
      }
      
      // ãƒ•ãƒ­ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
      initFlowField() {
        this.flowParticles = [];
        const count = 60;
        for (let i = 0; i < count; i++) {
          this.flowParticles.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            size: Math.random() * 4 + 2,
            trail: []
          });
        }
      }
      
      // ã‚¹ãƒ‘ã‚¤ãƒ©ãƒ«
        initSpirals() {
        this.spiralTime = 0;
        const spiralCount = Math.floor(Math.random() * 5) + 1; // 1ã€œ5å€‹
        this.spiralCenters = [];
        for (let i = 0; i < spiralCount; i++) {
            this.spiralCenters.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height
            });
        }
        }
      
      update() {
        this.time += 16; // ç´„60fps
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ‡ã‚Šæ›¿ãˆ
        if (this.time - this.lastSwitchTime > this.switchInterval) {
          this.initAnimation();
        }
        
        switch (this.currentAnimation) {
          case 'particles':
            this.updateParticles();
            break;
          case 'ripples':
            this.updateRipples();
            break;
          case 'geometry':
            this.updateGeometry();
            break;
          case 'constellation':
            this.updateConstellation();
            break;
          case 'flowField':
            this.updateFlowField();
            break;
          case 'spirals':
            this.updateSpirals();
            break;
        }
      }
      
      updateParticles() {
        this.particles.forEach(particle => {
          particle.x += particle.vx;
          particle.y += particle.vy;
          
          if (particle.x < 0 || particle.x > this.canvas.width) particle.vx *= -1;
          if (particle.y < 0 || particle.y > this.canvas.height) particle.vy *= -1;
          
          particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
          particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
        });
      }
      
      updateRipples() {
        this.rippleSpawnTimer++;
        if (this.rippleSpawnTimer > 6) {
          this.ripples.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            radius: 0,
            alpha: 1
          });
          this.rippleSpawnTimer = 0;
        }
        
        this.ripples = this.ripples.filter(ripple => {
          ripple.radius += 10;
          ripple.alpha -= 0.008;
          return ripple.alpha > 0 && ripple.radius < 400;
        });
      }
      
      updateGeometry() {
        this.geometryTime += 0.02;
        this.shapes.forEach(shape => {
          shape.rotation += shape.rotationSpeed;
          shape.x += shape.vx;
          shape.y += shape.vy;
          
          // å¢ƒç•Œã§åå°„
          if (shape.x < -shape.size || shape.x > this.canvas.width + shape.size) shape.vx *= -1;
          if (shape.y < -shape.size || shape.y > this.canvas.height + shape.size) shape.vy *= -1;
          
          shape.x = Math.max(-shape.size, Math.min(this.canvas.width + shape.size, shape.x));
          shape.y = Math.max(-shape.size, Math.min(this.canvas.height + shape.size, shape.y));
        });
      }
      
      updateConstellation() {
        this.stars.forEach(star => {
          star.x += star.vx;
          star.y += star.vy;
          star.brightness += star.twinkle;
          if (star.brightness > 1 || star.brightness < 0) star.twinkle *= -1;
          
          if (star.x < 0 || star.x > this.canvas.width) star.vx *= -1;
          if (star.y < 0 || star.y > this.canvas.height) star.vy *= -1;
          
          star.x = Math.max(0, Math.min(this.canvas.width, star.x));
          star.y = Math.max(0, Math.min(this.canvas.height, star.y));
        });
      }
      
      updateFlowField() {
        this.flowParticles.forEach(particle => {
          const angle = Math.sin(particle.x * 0.005) * Math.cos(particle.y * 0.005) * 6;
          const vx = Math.cos(angle) * 2;
          const vy = Math.sin(angle) * 2;
          
          particle.trail.push({ x: particle.x, y: particle.y });
          if (particle.trail.length > 30) particle.trail.shift();
          
          particle.x += vx;
          particle.y += vy;
          
          if (particle.x < 0) particle.x = this.canvas.width;
          if (particle.x > this.canvas.width) particle.x = 0;
          if (particle.y < 0) particle.y = this.canvas.height;
          if (particle.y > this.canvas.height) particle.y = 0;
        });
      }
      
      updateSpirals() {
        this.spiralTime += 0.05;
      }
      
      draw() {
        const isDark = document.body.classList.contains('theme-dark');
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        switch (this.currentAnimation) {
          case 'particles':
            this.drawParticles(isDark);
            break;
          case 'ripples':
            this.drawRipples(isDark);
            break;
          case 'geometry':
            this.drawGeometry(isDark);
            break;
          case 'constellation':
            this.drawConstellation(isDark);
            break;
          case 'flowField':
            this.drawFlowField(isDark);
            break;
          case 'spirals':
            this.drawSpirals(isDark);
            break;
        }
      }
      
      drawParticles(isDark) {
        // ç·šã‚’æç”»
        this.ctx.strokeStyle = isDark ? 'rgba(144, 255, 144, 0.1)' : 'rgba(0, 153, 0, 0.1)';
        this.ctx.lineWidth = 1;
        
        for (let i = 0; i < this.particles.length; i++) {
          for (let j = i + 1; j < this.particles.length; j++) {
            const dx = this.particles[i].x - this.particles[j].x;
            const dy = this.particles[i].y - this.particles[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 180) {
              const opacity = (1 - distance / 180) * 0.3;
              this.ctx.globalAlpha = opacity;
              this.ctx.beginPath();
              this.ctx.moveTo(this.particles[i].x, this.particles[i].y);
              this.ctx.lineTo(this.particles[j].x, this.particles[j].y);
              this.ctx.stroke();
            }
          }
        }
        
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æç”»
        this.particles.forEach(particle => {
          this.ctx.globalAlpha = particle.alpha;
          this.ctx.fillStyle = isDark ? '#90ff90' : '#009900';
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          this.ctx.fill();
        });
        
        this.ctx.globalAlpha = 1;
      }
      
      drawRipples(isDark) {
        this.ctx.strokeStyle = isDark ? 'rgba(144, 255, 144, 0.3)' : 'rgba(0, 153, 0, 0.3)';
        this.ctx.lineWidth = 2;
        
        this.ripples.forEach(ripple => {
          this.ctx.globalAlpha = ripple.alpha;
          this.ctx.beginPath();
          this.ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
          this.ctx.stroke();
        });
        
        this.ctx.globalAlpha = 1;
      }
      
      drawGeometry(isDark) {
        this.ctx.strokeStyle = isDark ? 'rgba(144, 255, 144, 0.2)' : 'rgba(0, 153, 0, 0.2)';
        this.ctx.lineWidth = 2;
        
        this.shapes.forEach(shape => {
          this.ctx.save();
          this.ctx.translate(shape.x, shape.y);
          this.ctx.rotate(shape.rotation);
          
          this.ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const x = Math.cos(angle) * shape.size;
            const y = Math.sin(angle) * shape.size;
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
          }
          this.ctx.closePath();
          this.ctx.stroke();
          
          this.ctx.restore();
        });
      }
      
      drawConstellation(isDark) {
        // æ˜Ÿã‚’æç”»
        this.stars.forEach(star => {
          this.ctx.globalAlpha = star.brightness * 0.6;
          this.ctx.fillStyle = isDark ? '#90ff90' : '#009900';
          this.ctx.beginPath();
          this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
          this.ctx.fill();
        });
        
        // æ˜Ÿåº§ã®ç·š
        this.ctx.strokeStyle = isDark ? 'rgba(144, 255, 144, 0.1)' : 'rgba(0, 153, 0, 0.1)';
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.3;
        
        for (let i = 0; i < this.stars.length; i++) {
          for (let j = i + 1; j < this.stars.length; j++) {
            const dx = this.stars[i].x - this.stars[j].x;
            const dy = this.stars[i].y - this.stars[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 200 && Math.random() < 0.15) {
              this.ctx.beginPath();
              this.ctx.moveTo(this.stars[i].x, this.stars[i].y);
              this.ctx.lineTo(this.stars[j].x, this.stars[j].y);
              this.ctx.stroke();
            }
          }
        }
        
        this.ctx.globalAlpha = 1;
      }
      
      drawFlowField(isDark) {
        this.ctx.strokeStyle = isDark ? 'rgba(144, 255, 144, 0.15)' : 'rgba(0, 153, 0, 0.15)';
        this.ctx.lineWidth = 2;
        
        this.flowParticles.forEach(particle => {
          if (particle.trail.length > 1) {
            this.ctx.beginPath();
            this.ctx.moveTo(particle.trail[0].x, particle.trail[0].y);
            for (let i = 1; i < particle.trail.length; i++) {
              this.ctx.globalAlpha = (i / particle.trail.length) * 0.4;
              this.ctx.lineTo(particle.trail[i].x, particle.trail[i].y);
            }
            this.ctx.stroke();
          }
          
          // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«è‡ªä½“ã‚‚æç”»
          this.ctx.globalAlpha = 0.6;
          this.ctx.fillStyle = isDark ? '#90ff90' : '#009900';
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          this.ctx.fill();
        });
        
        this.ctx.globalAlpha = 1;
      }
      
      drawSpirals(isDark) {
        this.ctx.strokeStyle = isDark ? 'rgba(144, 255, 144, 0.25)' : 'rgba(0, 153, 0, 0.25)';
        this.ctx.lineWidth = 3;
        
        this.spiralCenters.forEach((center, index) => {
          this.ctx.beginPath();
          for (let angle = 0; angle < Math.PI * 8; angle += 0.08) {
            const radius = angle * 5 + Math.sin(this.spiralTime + index) * 20;
            const x = center.x + Math.cos(angle + this.spiralTime) * radius;
            const y = center.y + Math.sin(angle + this.spiralTime) * radius;
            
            if (angle === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
          }
          this.ctx.stroke();
        });
      }
      
      animate() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.animate());
      }
    }
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–
    let animationManager;
    
    function initAnimationSystem() {
      const canvas = document.getElementById('background-canvas');
      animationManager = new AnimationManager(canvas);
    }
    
    // ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ©Ÿèƒ½
    function toggleTheme() {
      const body = document.body;
      const isDark = body.classList.contains('theme-dark');
      
      if (isDark) {
        body.classList.remove('theme-dark');
        body.classList.add('theme-tsuki');
      } else {
        body.classList.remove('theme-tsuki');
        body.classList.add('theme-dark');
      }
      
      // è¨­å®šã‚’ä¿å­˜
      const currentTheme = body.classList.contains('theme-dark') ? 'dark' : 'tsuki';
      document.cookie = `theme=${currentTheme}; path=/; max-age=31536000`; // 1å¹´é–“ä¿å­˜
    }
    
    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ãƒ†ãƒ¼ãƒã‚’å¾©å…ƒ
    function loadTheme() {
      const cookies = document.cookie.split(';');
      let theme = 'tsuki'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
      
      for (let cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'theme') {
          theme = value;
          break;
        }
      }
      
      const body = document.body;
      body.classList.remove('theme-tsuki', 'theme-dark');
      body.classList.add(`theme-${theme}`);
    }

    document.addEventListener('DOMContentLoaded', function() {
      loadTheme();
      initAnimationSystem();
    });
  </script>
</body>
</html>