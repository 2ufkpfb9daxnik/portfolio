---
title: "プログラミングの教育の段階、順序などについて"
---

私は大変良い教育を受けたと思っていますが、しかし、それでもその教員と少々思想に齟齬が出てきて、今では私が辿ってきた初級のプログラミングの教育は、悪いとはいいませんがもう少しこうあってほしかったというような考えがよく溜まってきました。それをまとめて、ではどのようにすればよいか？ということを考えてみたいと思います。

## 実際受けた内容

まず以下に私の受けてきたプログラミング教育について以下に示します。

- [私が受けてきた初級のプログラミング](https://takeshiwada1980.github.io/Programming1-2023/)は、高専2年のこれが初めです。それまではほとんどプログラミングのようなことはおそらくしたことがなかった
- ↑と同時期に、マイクロコンピューターという授業で、ArduinoをC言語で動かしていました

- 高専3年(前期)になって、プログラミング2という授業でまたC言語をやりました。といってもほとんどArduinoで知っていたので、そこでは扱っていなかった構造体やポインタのことを中心にやっていましたが、それ以外は、今思うと何をやっていたのかほぼ覚えていません。あんまりまともな課題もなかったと思うし。
- ↑と同時期に、pythonのflaskでちょっとしたサーバーを立てるような実験もしました。
- [後期では、またこの大変丁寧な授業資料で、贅沢なreactとnext.jsの授業を受けておりました。](https://takeshiwada1980.github.io/Programming3-2024/)

- 4年からは、直接プログラミング(のためのプログラミング！)という感じの授業はありませんが、実験でラズパイの制御を書いたり、自然言語処理に使ったり、色々**応用で使うことになっています**

まとめると、基本的に、一番はじめのpythonによるプログラミングの入門が軸となって、他の実験や科目で使えますよね、こういう概念ありますよね、というふうに参照及び使用するという構成になっていると思います。

## 考え

pythonは流石のカバー範囲で並大抵のことは全てできる+ハードウェア系+AI応用+科学技術応用なども凄まじく、一見よく見えるのかもしれません。しかし、私はそのような理由よりも、もっと本質的なプログラミングの理解のために、重要な点が抜けていると思います。

pythonは普通型を書きません。これは最悪です。型を書くという行為は最も基本的なプログラミングの理解に繋がります。型を書かないと、プログラムの構造が曖昧になります。構造が曖昧になると、プログラムの設計が曖昧になります。設計が曖昧になると、プログラムの動作が曖昧になります。動作が曖昧になると、バグが発生しやすくなります。バグが発生しやすくなると、デバッグが困難になります。デバッグが困難になると、プログラムの保守性が低下します。保守性が低下すると、プログラムの寿命が短くなります。。。

とかなり批判しましたが、実際これは本当にそうだと思っています。少なくとも、型を書くことによって、データの持つ性質を明らかに理解し、それをどのように調理するか、あるいは、どのような調理は不可能であるかを明確にすることができます。これは初学者にとって大変重要であると考えます。

> ここまでは、**あえて**言及を避けてきましたが、Python においても、C/C++言語 (Arduino言語)、Java と同様に 型 (Type) が存在して機能しています。

とまで言っていて、目も当てられません。

さて、それではどのような言語がいいかということですが、要件から定めることにしましょう。

初学者向けのプログラミングの授業で、1年かけて授業をやるとき、どのよな能力を達成していてほしいでしょうか？対象は情報学部の学生です。

ここで私とその教員の齟齬が出てきますが、私は以下のような能力を達成してほしいと考えています。

- データに付く型、変数、条件分岐、繰り返し処理、配列(リスト)、関数
- オブジェクト指向プログラミング
- 外部ライブラリ
- Git(Hub)
- 簡単なアルゴリズムとデータ構造
- 簡単な設計技法
- 簡単なテスト技法
- 簡単なデバッグ技法

しかし、特に初学者の学生は、外部へのグラフィカルな出力でしか楽しみを得ることができませんとはいいませんが、かなり難しいです。これはまあ仕方ありません。私もそうでした。わかります。この点その教員は大変工夫されていて、タートルグラフィックス、数学の課題と組み合わせる(これは科研費研究の一環だったかな)、ゲームっぽい題材を積極的に扱う、物理シミュレータを考える、opencvやpygameで見た目に楽しいものを作る、pysideでGUIを作る、など、非常に工夫されています。これは大変良いことだと思います。しかし、しかしですよ、これらは全て、本質的な理解を妨げる可能性があります。問題なのは、これらが本質的な理解の部分と一緒くたになって、ぐちゃぐちゃに絡まった状態で提供されているということです。そうではなくて、まず本質的な理解の部分をしっかりと提供し、その後に、その応用としての外部へのグラフィカルな出力を提供すべきと考えます。

逸れましたが、ではどのような言語が良いかということですが、以下のような点から、C#が良いと考えます。

- 静的型付け言語であり、型を書くことが必須である
- オブジェクト指向プログラミングが自然にできる
- 広く世の中で使われており、調べたときにたくさん情報が出てくる
- 標準ライブラリが巨大で、さらに外部ライブラリも豊富である
- Unityの存在
- ほとんどの実行環境で動作する

まず型についてですが、これは前述のとおりです。型を書くことは、プログラムの構造を明確にし、設計を明確にし、動作を明確にし、バグを減らし、デバッグを容易にし、保守性を向上させ、寿命を延ばします。

次オブジェクト指向プログラミングですが、正直あんまり好きではないんですが、ほとんどのプログラミング言語はこの方式で構造化されています。外部ライブラリもオブジェクト指向で提供されていることが多いです。この方式を学んでおかないと、一介のプログラマとしてはまだ致命的であると考えます。

次に、広く世の中で使われていることですが、これは初学者にとって大変重要です。調べたときにたくさん情報が出てくるのは、確かにどれが正しいのかわからなくなるかもしれませんが、それでも、調べたときに情報が出てこない言語よりは遥かに良いです。今ならAIもありますが、やっぱりそれも学習量がたくさんある方が精度の良い回答が得られます。

さらに、標準ライブラリが巨大で、さらに外部ライブラリも豊富であることも重要です。しばらくこの1つの言語を使い続けることになるので、自分で色々原理的なAPIを叩くとかそういう高度なことをしなくても、標準ライブラリや外部ライブラリで大抵のことができるというのは初学者向けであると考えます。

また、Unityの存在も大変重要です。ゲームは情報学科のほぼ全員が選んだ理由であり、これを外して語ることはできません。

最後に、ほとんどの実行環境で動作することも重要です。Windows、Mac、Linux、WebAssembly、モバイルなど、様々な環境で動作することができるので、先述の通り1つの言語を長く使い続けるという点において有利に働きます。

そして具体的な授業内容ですが、以下のようなスケジュールを考えます。

| 段階 | 内容 |  詳細  |
|----|------| -------------------------|
| 1  | プログラミングとは、環境構築、Hello World(標準出力) |  様々な文字列を出力してみる  |
| 2  | 標準入力、変数、型、基本的なデータ型、四則演算 |  整数型、浮動小数点型、文字列型、論理型、それらの組み合わせの演算、発展として値型/参照型  |
| 3  | 条件分岐、繰り返し処理、超問題演習1 |  if文、switch文、for文、while文、簡単なじゃんけんゲーム、AtCoder Beginner Contest のA問題を50問解く |
| 4  | 超問題演習1の続き | AtCoder Beginner Contest のA問題を50問解く |
| 5  | 配列(リスト)(多次元まで)、関数 | 配列の宣言、初期化、アクセス、ループでの利用、関数の定義、引数、戻り値、簡単な電卓プログラム/あるいは自作の別のプログラム(donut.cのようなプログラムに挑戦してみよ！と提示する) |
| 6  | hashmap、セット、超問題演習2 |  辞書型、集合型、AtCoder Beginner Contest のB問題を50問解く|
| 7  | 超問題演習2の続き | AtCoder Beginner Contest のB問題を50問解く|
| 8 | オブジェクト指向プログラミング |  インターフェース、抽象クラス、カプセル化（アクセス修飾子）、コンストラクタ／デストラクタ、プロパティとフィールド、メソッドのオーバーロード・オーバーライド、ジェネリクス（総称型）、委譲（合成）と依存注入|
| 9  | 外部ライブラリの利用、NuGet  |  NuGetの使い方、外部ライブラリの導入、簡単な画像処理プログラム |
| 10 | Git(Hub)の利用 |  Gitの基本操作、GitHubの利用、簡単なチーム開発演習 |
| 11 | 簡単なデータ構造とアルゴリズム |  ソート(関数だけで、内部実装はまあ参考程度に)、スタックとキュー、グラフ(状態遷移)と木構造、二分探索、BFS/DFS、応用として国語辞典から目的の単語を調べるプログラムと、迷路の探索をするプログラムを作る、発展として文字列アルゴリズム、累積和、しゃくとり法、DP |
| 12 | 簡単な設計技法 |  UML、設計パターン、MVCモデル、実際に簡単な設計をしてみる |
| 13 | 簡単なデバッグ |  デバッガの使い方、ログ出力、例外処理 |
| 14 | 簡単なテスト |  単体テスト、結合テスト、システムテスト、簡単なテストコードの作成 |
| 15 | 総合演習1 |  簡単なソフトウェアあるいはゲームなどの開発、チーム開発 |
| 16 | 非同期処理、 |  async/awaitの使い方、非同期プログラミングの基礎、簡単なネットワークプログラム |
| 17 | ラムダ式、再帰関数・高階関数、クロージャ |  ラムダ式の詳細、再帰関数の定義と利用、高階関数の定義と利用、クロージャの概念と利用 |
| 18 | LINQ |  データベースの概念の説明、LINQの詳細、LINQを使ったデータ操作、クエリ構文とメソッド構文の使い分け |
| 19 | 総合演習2 あるいは 超問題演習3 |  簡単なソフトウェアあるいはゲームなどの開発、チーム開発あるいは、AtCoder Beginner Contest のC問題以上を50問解く |
| 20 | おまけか、あるいは夏休みにやりたい人だけ? |  Unityの基礎、簡単なゲーム開発、3Dの入門はautochessが楽だと思う |

実際は、2、3週目を1週でやって超問題演習1に2週間とるとかやることになると思います。というのは実際とにかく手を動かさないことには身につかないので。そういう点で超問題演習2も、実際は5, 6を1週でやって2週間とるとかになると思います。というような内容を考えていたら、大体これを1年程度でやるのがいいんじゃないかと思います。発展という部分はまあしなくてもいいです。

## 引用

以下は私が共感できる引用です。この辺の思想をうまいこと組み合わせて、プログラミング教育をするのが、情報学科のためには、いいんじゃないかと思うんですが...

### 分割統治

タイトルが圏論とか大層なことを書いていますが、分割統治こそプログラミングの本質であるという、最もなこと言っているだけですが、しかし書き下すことは本当に重要です。

> この階層的な分解と統合のプロセスは，別にコンピュータが我々に要請しているものではない．これは人間の思考の限界を反映している．我々の脳は，いくつかの考察しか同時に行うことができない．心理学において最も引用されている論文 The Magical Number Seven, Plus or Minus Two が立てた仮説によれば，我々は 7±2 個の "塊" の情報しか同時に頭に入れておくことができない．人間の短期記憶に関する学術的な詳細は今後変わるかも知れないが，とにかくとても限られているという事実は確実だ．少なくとも，オブジェクトのスープやコードのスパゲッティを扱うことはできない．
>
> 我々がプログラムに構造を必要とするのは，綺麗に構造化されたプログラムは見栄えが良いからではなく，さもなくば我々の脳は効率的に処理できないからだ．我々はしばしばコードをエレガントだとか美しいとか表現するが，それが意味するのは我々の限られた思考能力で簡単に処理できるということだ．エレガントなコードは，我々が消化し吸収するのに，ちょうど良いサイズの塊で，ちょうど良い個数で表現されている．
>
> [(訳)さのたけと『プログラマのための圏論』(Bartosz Milewski "Category Theory for Programmers" の翻訳より)](https://zenn.dev/taketo1024/books/850b20937af93b/viewer/1-3)

### 言語処理系

以下は、かなり強い思想ですが、これこそが情報学科が、計算機科学を真摯に学ぶ者が、学ぶべきことであると私が考えていることです。

> プログラム設計の勉強で, 熟練プログラマは, 設計の複雑さをすべての複雑なシステムの設計者が使うのと同じ一般的技法を使って制御するのを見た. 基本要素を組み合せて合成オブジェクトを作り, 合成オブジェクトを抽象化して高水準の組立てブロックを作り, システム構造の適切で大規模な視点を採用し, 部品化力を保持する. これらの技法の例示に, 実世界の複雑な現象をモデル化するプロセスを記述したり, 計算オブジェクトとプロセスを構成したりする言語としてLispを使ってきた. しかし徐々に複雑な問題に立ち向うにつれ, Lispや他の固定したプログラム言語は目的に不十分なことが分ってくる. われわれの考えをより効果的に表すため, 絶えず新しい言語に変らなければならない. 新しい言語を創るのは工業設計で複雑さを制御する強力な戦略である: 手元の問題に特によく適合した, 基本演算, 組合せ手段, 抽象手段を用いて, 問題を異る方法で記述する(従って考える)ことが出来る新しい言語を採用し, 複雑な問題を扱う能力を拡大することが多い.1
>
> プログラミングには多くの言語が使われる. 特定の計算機の機械語のような, 物理的言語がある. こういう言語は記憶装置や基本的機械命令の個々のビットを使ったデータや制御を表現することに関係する. 機械語のプログラマは, 与えられたハードウェアを使い, 資源に制約された計算の効率よい実現のためのシステムや, ユーティリティを構成しようとする. 機械語の基盤の上に構成された高水準言語は, ビットの集りとしてのデータの表現や, 基本演算の列としてのプログラムの表現の考え方を押し隠す. これらの言語は, 手続き定義のような, システムの大規模構成に適した合成と抽象の手段を持っている.
>
> 新しい言語を創設する 超言語的抽象(metalinguistic abstraction) は, 工学的設計のすべての分野で重要な役割を果す. これはプログラミングにおいて, 新しい言語が形式化出来るだけでなく, 評価器を構築してこれらの言語を実装し得るが故に, 特に計算機のプログラミングで重要である. プログラム言語の 評価器(evaluator)(または解釈系(interpreter))とは, その言語の式に作用させられると, その式を評価するのに必要な行動を実行する手続きのことである.
>
> これをプログラミングの最も基本的な考えと見るのは決して誇張ではない:
>
>> プログラム言語での式の意味を決定する評価器は, もう一つのプログラムに過ぎない.
>
> この点を認めるのはプログラマとしてのわれわれ自身の見方を変えることである. われわれは他人の設計した言語の利用者であるよりは, 言語の設計者として自分を見るようになる.
>
> 実際殆んどのプログラムは, ある言語の評価器と見ることが出来る. 例えば2.5.3節の多項式操作システムは, 多項式演算の規則を具体化し, それらをリスト構造のデータの演算を使って実装したものである. このシステムに, 多項式表現を読み込んだり, 印字したりする手続きを追加すれば, 記号演算の問題を扱う特殊目的の言語の中核が得られる. 3.3.4節のディジタル論理シミュレータや, 3.3.5節の制約伝播系は, それ自身, 独自の基本演算, 合成手段や抽象手段を持った正当な言語である. こういう見方をすると, 大規模計算システムに対処する技法は, 新しい計算機言語を構成する技法と一体になり, 計算機科学それ自身は, 適切な記述言語を構成する修練に過ぎ(ず, 不足もし) なくなる.
>
> では他の言語を使って言語を創設する技法への旅に出発しよう. 本章では, Lispを基盤として使い, 評価器をLispの手続きとして実装しよう. Lispは, その記号式を表現し操作する能力の故に, この作業に特に適している. その第一歩として, Lisp自身の評価器を構成することで, 言語がどう実装されているかを理解しよう. われわれの評価器で実装する言語は, 本書で使っているLispのScheme方言の部分集合である. この章で記述する評価器は, Lispの特定の方言で記述してあるが, 逐次型計算機のプログラムを書くために設計した式主体の言語の評価器の本質的な構造を含んでいる. (実際, 殆んどの言語処理系は, その根底に小さな「Lisp」評価器を持っている.) この説明と議論のため, 評価器は単純化され, 製品品質としてのLisp処理系には重要な機能の一部も取り除いてある. それにも拘らずこの単純な評価器は, 本書のプログラムの殆んどを実行するのに適している.2
>
> 評価器をLispプログラムとして手が届くようにする重要な利点は, 評価器プログラムの修正として記述し, 別の評価規則が実装出来ることにある. この能力を巧みに使う一つの場所は, 3章の中心的論点であった計算モデルが, 時の観点を具体化するいろいろな方式の制御を試みる所である. そこでは状態と代入による複雑性を幾分緩和し, ストリームを使って実世界の時の表現を計算機内の時から分離した. しかしわれわれのストリームプログラムは, Schemeの作用的順序評価によって制約されているので,ある程度煩わしい. 4.2節では基底の言語を変更し, 評価器に正規順序評価 (normal-order evaluation)が出来るように修正することで, より優美な解決法が出来るようにする.
>
>> 1 この考えは工学のすべてを通じて広まっている. 例えば電気工学者は回路記述に多くの異った言語を使う. それらの二つをあげれば, 電気的ネットワーク(network)の言語と電気的システム(system)の言語である. ネットワーク言語は離散的電気素子を使った部品の物理的モデル化を強調する. ネットワーク言語の基本オブジェクトは, 電圧と電流という物理的変数を使って特徴づけられる, 抵抗, キャパシタ, インダクタやトランジスタのような基本的電気部品である. ネットワーク言語で回路を記述する時, 技術者は設計の物理的特性に注目する. 対照的にシステム言語の基本オブジェクトはフィルタや増幅器のような信号処理部品である. 部品の関数的振舞いだけが重要で, 電圧や電流のような物理的実在に関心がなく, 信号だけを操作する. システム言語は, 信号処理システムの要素は電気的ネットワークで構成されているという意味で, ネットワーク言語の上に構成されている. ここではしかし, 関心は与えられた応用問題を解くための電気的部品の大規模な構成であって, 標準部品の物理的実現可能性は仮定されている. 言語のこういう階層的集成は, 2.2.4節の図形言語で示した成層設計技法のもう一つの実例である.
>
> [(訳)和田英一『計算機プログラムの構造と解釈』(Harold Abelson and Gerald Jay Sussman "Structure and Interpretation of Computer Programs" の翻訳より)](https://sicp.iijlab.net/fulltext/x400.html)

いつ見返してもいい文章です。本当に素晴らしい。今MITの入門は流石にこれじゃなくなってるみたいですが、応用のためではなくて、純粋な計算機科学の学習のためには、そしてプログラミング言語を学習するという手段としては、やはり処理系を自分で作るというのは最も良い方法だと思います。そして、これは他の方も似たような感じのことを言っています:

> 最初に、この実験における基本的な考え方を説明しておく。
>
>プログラム言語を知る最善の方法は、そのプログラム言語の処理系を書くことである。
>
> 新しいプログラム言語を教えるとき、通常ならば、まず、その使い方に習熟し、 しかるべき後にその処理系の構成などを習うであろう。この実験では、 そうではなく、ほんの 1-2週間の使い方の練習の後、 すぐさま、言語処理系の作成をはじめる。つまり、プログラム言語の使い方を理解することと、 処理系を作成することがほとんど同時進行でおこなわれる。
>
> たとえば、fun x -> e という式は関数を表すが、 いったいこれの意味は何かまだよくわかっていないうちに、その形式を処理するプログラムを書き始めるのである。
>
> このようにする理由は、時間を節約するためではなく、 「処理系を作成することが、そのプログラム言語を本当に理解するための近道である」という考え方による。
>
> [亀山幸義『プログラム言語処理系実験』より](https://www.logic.cs.tsukuba.ac.jp/jikken/)

どっちもOCamlの人で思想出てるかも

> 計算機言語を “理解” する最良の方法は，その言語の或る程度大きめのサブセットの操作的意味論を手で書き起こすことです．
>
> [画力・博士号・油田(@bd_gfngfn)の2018年8月25日午後4:06の投稿](https://x.com/bd_gfngfn/status/1033249301361639425)

### プログラマ的感覚

以下は、冒頭の私と思想が合わない教員の思想に近い(と私が勝手に思い込んでいる)引用です。しかし、非情報学科向けとしては、最も適切な考え方であると思います。少なくとも情報学科の学生に対しては、もう少し踏み込んだ教育が必要であると思います。

> では何を目的とするか。それは「これくらいのプログラムを書けば、これくらいのことができるんだなぁ」という「感覚」を身につけることだ。これから短いプログラムから、それなりに長いプログラムまで多数組むことになるが、そこで文法とか、ライブラリの使い方などを覚える必要はない。ざっくりと「Pythonにはこんなライブラリがあり、それを使うとわずか数行でこれくらいのことができる」ということを頭の片隅に置いてくれればそれでよい。
>
> なぜプログラムを覚えるべきか。それは今後プログラムが就職活動に必須スキルになるからでもなく、ましてAIがブームだからでもない。「プログラマ的な感覚」を身につけるためだ。たとえ日常的にプログラムを組んでいなくとも、「プログラマ的な感覚」を身に着けた人は、そうでない人に比べて作業能力が桁違いに上がる可能性がある。
>
> 例を挙げよう。あなたは、あるフォルダの中にある100枚くらいの画像を全て半分にリサイズしなければならない。とりあえずWindowsを使っていて「ペイント」を使ってファイルを開き、「Ctrl+E」でイメージのプロパティを開けば幅と高さを調整できることは知っているとしよう。「プログラマ的な感覚」がなければ、頑張って「ペイント」で100枚修正してしまうかもしれない。
>
> ここで、本書を読んだ人は、詳細は覚えていなくとも「少なくともPythonには画像を扱うライブラリがあり、リサイズもできるはずで、またフォルダの中のファイル一覧も簡単に取れるに違いない」と思うだろう。そして「Python 画像 リサイズ」や「Python フォルダ ファイル 一覧」などのキーワードで検索し、以下のようなコードを書く。

```python
import glob
from PIL import Image

for file in glob.glob("*.png"):
    img = Image.open(file)
    (w, h) = img.size
    img.resize((w//2, h//2), Image.LANCZOS).save("resized/"+file)
```

> カレントディレクトリにあるPNGファイルを、半分のサイズにしてはresizedというフォルダに放り込んでいくスクリプトである。たった6行だ。
>
> もしくは、「これくらいのことならPythonを使うまでもないかもしれない」と思い、「画像　リサイズ　一括」というキーワードで検索して、ImageMagickというツールにたどり着くかもしれない。それなら一行でできる。
>
```mogrify -path resized -resize 50% *.png```
>
> ここで重要なのは「PythonのglobやPILというライブラリの存在や使い方を覚えていること」でも「ImageMagickというツールを知っていること」でもない。「これくらいのことなら数行でできるに違いない」という感覚である。プログラマ的な感覚を身に着けていない人は、そもそも「これは簡単にできるだろう」という発想がないため、検索もできない。
>
> もしかしたら「プログラムの素養がなくたって画像のリサイズくらいなら自動でできると思いつく」と思うかもしれない。では、こんな課題はどうだろう？あなたは卒業研究でトランジスタの特性を調べることになった。それぞれのトランジスタにはあるパラメタがあり、異なるパラメタを用いて作られている。そのトランジスタの電圧ー電流特性が、以下のようなテキストファイルに保存されているとしよう。

```txt
0.0 0.0
0.1 0.01
0.2 0.2
0.3 0.8
...
```

> このようなデータが、トランジスタのパラメタを含めてdata_48.datといった名前で保存されており、それが100個近くある。トランジスタは、ゲートにかける電圧がある「しきい値」を超えると電流が流れ始める。このデータに適当にフィッティングをかけることで、「しきい値」を求めたいとしよう。ファイルそれぞれのデータにフィッティングをかけて、ファイル名のうしろにある値(この場合は48)をx軸に、しきい値をy軸にしてプロットしたい。
>
> 「画像のリサイズ」は一般的なニーズだからツールがあるが、この卒論のテーマはあなたしかやっていないからそんな便利なツールはない。ここで、もし「プログラマ的な感覚」がなければ、一つ一つエクセルでファイルを開き、スレッショルドを求めて、別のエクセルシートにパラメタとして記入していくかもしれない。そして徹夜で作業して「卒論がんばってる！」と錯覚するかもしれない。しかし、もしあなたが「プログラマ的な感覚」を持っていれば、「これはPythonを使えば、長くても数十行でできるな」と思うはずだ。
>
> くりかえしになるが、必要なのは「知識」ではなく「感覚」である。「globを使ってファイル一覧を取得し、SciPyのcurve_fitでフィッティングをかけることができる」ということを覚えておく必要はない。大事なのは「そういうことが簡単にできるはずだ」と思うことで、そう思うことができれば「Python フィッティング」で検索すればすぐにscipy.curve_fitにたどり着けるはずだし、もしかしたらPythonではなくRを使いたくなるかもしれない。調べて試してみるたびに、あなたのスキルはどんどん増えていくことになる。
>
> こういった考えは別にPythonに限らない。エクセルを使っていても、面倒な処理を見た時に「これは一括でできるマクロがあるに違いない」と思って探すかどうか。毎日決まった時間に、あるウェブサイトにアクセスして、ある値を読み取らないといけないという「仕事」が与えられた時に、「ウェブサイトにアクセスして値を読み込めるツールがあるに違いない。毎日決まった時間に何かを自動的に実行する方法があるに違いない。それを組み合わせれば良い」と思えるかどうか。これが「プログラマ的発想」である。
>
> こういう発想ができるようになれば、日々の作業効率が飛躍的に向上するのが想像できるであろう。別に全ての作業を自動化する必要はない。プログラムは何かの目的を達成するための手段の一つに過ぎず、プログラムするか、ツールを導入するか、それとも今回は手でやるか、自動化のためのコストと、自動化しなかった時のコストを考えて、その時その時に最適と思える選択をすればよい。
>
> 細かい文法などは最初は気にせず、必要に応じて調べれば良い。「Pythonはこういうことができるんだな」「それはこれくらいの作業量でできるんだな」という「感覚」を頭の片隅に残すこと、それを目的として学習して欲しい。
> 
>[kaityo256『ゼロから学ぶPython』より](https://kaityo256.github.io/python_zero/introduction/index.html)
