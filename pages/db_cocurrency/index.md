---
title: 関係データベースにおける同時実行制御
---

[データベース工学という講義の課題2](https://takeshiwada1980.github.io/DB-2025/lecture13.html)

## 概要

wikipediaから引用:

    データベースへの読み書き（トランザクション処理）には処理時間が発生する。複数のトランザクション処理依頼がデータベース管理システムへ行われたとき、これらを処理する1つの方法は逐次的（Serial）に1つずつトランザクションを処理する方法である。トランザクション処理に処理時間がかかることから、後に行われた処理は先に行われた処理が完了するまでの間「待ち」の状態になってしまう。

    待ちを最小化するためにはデータベース管理システムが複数のトランザクションを並行（Concurrent）に処理すればよい。しかしトランザクションは必ずしも安全に並列化できるとは限らない。そのためデータベース管理システムは各並行トランザクションが互いに影響を受けず分離された安全な範囲内でトランザクションを並行化する。あるいは、異常な振る舞い（anomalies）を起こしうる分離レベルが低い並行化を許容し、代わりに並行性を高めてトランザクション処理性能を上昇させる[1]。この安全性・一貫性と性能のトレードオフを生む、並行性トランザクションの分離具合がトランザクション分離レベルである[2]。

    トランザクション分離レベルはシステム要件に合わせデータベースの設計者によって設定される。例えば一切の異常な振る舞いが許されない金融システムには高いトランザクション分離レベルが設定される（代わりに性能は低い）。またanomaliesの可能性がある分離レベルを選択してもanomaliesを起こしえないトランザクションのみを処理するように設計すれば一貫性を保ちながら高い性能を得ることが可能になる。

テーマ設定：「複数のユーザーが同時にアクセスすると、データはどう壊れるのか？」

導入：なぜ同時実行制御が必要か？ (読むだけ)
身近なトラブルの例: * 「スマホゲームで、残り1個のレアアイテムを、AさんとBさんが全く同時に『購入ボタン』を押したらどうなる？」

「順番に処理すれば問題ないが、同時に処理すると『1個しかないのに2人とも買えてしまう』かもしれない。」

本記事の目的: トランザクションと「隔離レベル（Isolation Level）」の違いを、PostgreSQLの環境で実際にバグを起こしながら理解する。

実験準備：2つのターミナルを並べる (ハンズオン)
テーブルの準備: 非常にシンプルな bank_accounts（銀行口座）テーブルを作成し、初期データを入れる。

環境構築: Docker上のPostgreSQLに対し、ターミナルソフトを2つ（セッションAとセッションB）開き、画面を左右に並べて配置するよう読者に指示する。これ以降、読者はAとBを交互に操作して「同時アクセス」を疑似体験する。

実験編：データベースの「3つの怪奇現象」 (ハンズオン＆解説)
データベースの世界で有名な3つのアノマリー（不整合現象）を順番に体験させます。

現象1：Dirty Read（ダーティリード）

内容: Aさんが更新中でまだ確定（コミット）していないデータを、Bさんが読んでしまう現象。

実験: PostgreSQLではデフォルト設定（Read Committed）の時点で、この現象が発生しないように守られていることを確認する。

現象2：Non-Repeatable Read（ノンリピータブルリード）

内容: Bさんが同じトランザクション内で2回データを読んだとき、その間にAさんが更新してしまったせいで、1回目と2回目でデータが変わってしまう現象。

実験: 実際にターミナルを交互に操作して、さっきまで「残高1000円」だったのに、もう一度 SELECT すると「残高500円」に変わる恐怖を体験。

解決: 隔離レベルを REPEATABLE READ に上げて再度実験し、「過去のデータ（スナップショット）が見え続ける」ことで現象が防げることを確認。

現象3：Phantom Read（ファントムリード）
*

内容: Bさんが「残高1000円以上の人」を検索している間に、Aさんが新しく「残高2000円の人」を新規登録（INSERT）すると、2回目の検索で急に幻のデータ（ファントム）が増える現象。

発展実験：現場で一番怖い「Lost Update（更新の喪失）」 (ハンズオン)
ここが記事の一番の盛り上がりどころです。

内容: AさんとBさんが同時に「自分の口座に+1000円する」処理をしたのに、合計+2000円にならず、+1000円にしかならない（片方の更新が上書きされて消える）バグ。

実験: デフォルト設定でわざとLost Updateを発生させる。

解決策の提示: 1.  隔離レベルを SERIALIZABLE（最高レベルの厳密さ）にして、エラーで弾く方法。
SELECT ... FOR UPDATE（行ロック）を使って、Aさんの処理が終わるまでBさんを「待たせる」方法。（※実務でよく使う手法として紹介）

まとめ：PostgreSQLの隔離レベル一覧
ここまでの実験を踏まえ、各隔離レベル（Read Committed, Repeatable Read, Serializable）がどの現象を防げるのかをまとめた表を提示する。

定着確認ドリル＆演習 (読者が解く)
問題1（知識の確認）: 隔離レベルと防げる現象の組み合わせを選ぶ選択問題。

問題2（SQL演習）: 「イベントの座席予約システム」のテーブル定義を提示し、「Aさんが予約処理をしている間に、Bさんが同じ席を予約できないようにするSQLのトランザクションを書きなさい（行ロックを使用）」といった実践的な問題を出す。

解答例と解説を記事の末尾または別リンクに記載。

```codetest
print("hello world")
a = int(input())
```